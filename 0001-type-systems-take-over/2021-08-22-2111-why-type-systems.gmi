# Why type systems matter?

## A fistful of formal methods

We want our programming language environments at large to be able to tell well-behaved programs from those that behave poorly. It doesn't matter how it's achieved. 

* Runtime monitoring which includes things like operations on incompatible objects (a la Python and JavaScript) and underappreciated contract programming based on preconditions and postconditions, as well as invariant checking (a la DLang) [4].
* Some will remember model-driven engineering with UML modelling (my Vim highlighted "UML" as a non-existent word! It brings me joy). Automatically deriving constraints from such models and rejecting models that are self-contradicting or breaking some constraints. (a la EMFtoCSP [3]).
* Both digital and analog circuits can be accepted or rejected based on automatically derived finite state machine models and checking for desired properties [1][2].
* Type systems for rejecting classes of poorly-behaved programs statically, during compilation (a la Java).

Rather interesting observation is that these discriminators should be reproducible, which calls for underlying formalisms. Furthermore, it's preferred that domain experts (JavaScript programmers, UML architects, embedded systems engineers) can reap benefits from those. That property is called "lightweight" in culture. When we put these considerations together, we see that all of these things, including JavaScript's runtime monitoring, which many people may deem as basic, are lightweight formal methods! Not scary at all.

Not all formal methods, however, are made for the same reason and not everything achievable with one can be achieved with another. To illustrate that, consider the following use-case: we build up an array of validation functions and then, at the validation site we call them one by one.


```JavaScript listing with line numbers
01 |	let module1 = {
02 |	  defaultValidators: [
03 |	    (x) => 2 == x.split(' ').length,
04 |	  ],
05 |	  validate: (input) => (fs) =>
06 |	    fs.reduce((acc, f) => acc && f(input), true),
07 |	};
08 |	
09 |	let module2 = {
10 |	  alsoCapitalised: [
11 |	    (x) =>
12 |	       x.split(' ').reduce(
13 |	         (acc, x) => acc && (/[A-Z]/.test(x[0])), true
14 |	       )
15 |	  ] + module1.defaultValidators,
16 |	}
17 |	
18 |	let main = {
19 |	  main: (input) => {
20 |	    let validators = module2.alsoCapitalised;
21 |	    if (module1.validate(input)(validators)) {
22 |	      console.log("It's time to open the door");
23 |	    }
24 |	  }
25 |	}
26 |	
27 |	main.main("Viktor Tsoi");
```

When we run this code, the following error will be reported:

```JavaScript type error
Uncaught TypeError: fs.reduce is not a function
    validate debugger eval code:6
    main debugger eval code:21
    <anonymous> debugger eval code:27
```

The true place where the error happens is line 15. Getting there from lines 6 and 21 would probably require a little bit of debugging, especially in a real project. Indeed, the error happens due to nonsense operation `+` over two arrays. Let's fix it:

```Fixed line fifteen
15 |	  ].concat(module1.defaultValidators),
```

When we run the code again, we get the expected message in the log:

> It's time to open the door

Let's compare runtime monitoring with a type system.
Here's code with the same error in Haskell.

``` Code snippet showing a similar Haskell compile time error
01 |	{-# LANGUAGE OverloadedStrings #-}
02 |	import qualified Data.Text as T
03 |	import Data.Text( Text(..) )
04 |	import Data.Char( isUpper )
05 |
06 |	defaultValidators :: [Text -> Bool]
07 |	defaultValidators = [\x -> 2 == (length $ T.splitOn " " x)]
08 |
09 |	validate :: Text -> [Text -> Bool] -> Bool
10 |	validate input fs = foldl (\acc f -> acc && f input) True fs
11 |
12 |	alsoCapitalised :: [Text -> Bool]
13 |	alsoCapitalised = [\x -> foldl (\acc w -> acc && (isUpper $ T.head w))
14 |	                               True
15 |	                               (T.splitOn " " x)] + defaultValidators
16 |
17 |	main :: IO ()
18 |	main =
19 |	  case validate input defaultValidators of
20 |	    True -> putStrLn "It's time to open the door"
21 |	    _    -> putStrLn "Close the door behind me"
22 |	  where
23 |	    input = "Viktor Tsoi"
```

When we try to compile it, we're going to get an error that says exactly what is wrong. To be able to apply `+`, operands had to be classified as numbers via typeclass `Num`. This typeclass doesn't include lists of validator functions. Note that if we would really want to define addition on such values, we would be able to, by providing an instance of `Num`. But it's a rather horrible idea, so we'll fix the bug instead.

```Informative Haskell compile-time error, pinpointing the faulty location
/tmp/hi.hs:13:19: error:
    No instance for (Num [Text -> Bool]) arising from a use of '+'
```

With this error, we quickly can replace line 15 with one using `++`, the list concatenation operator:

```Fixed line 15
15 |	                               (T.splitOn " " x)] ++ defaultValidators
```

When we run this one, we get the correct result!

Static checking allows us to catch errors like this one early, which saves a lot of money while dealing with many errors, since--as systems engineering teaches us--the cost of fixing a fault in a system grows exponentially as a function of how far it is from the requirement gathering stage in the lifecycle of a system.

### Benefits of using type systems

Type systems come in different shapes and sizes: different type systems may be geared to eliminate different classes of incorrect programs. However, most of type systems--collaterally--eliminate programmers' errors such as incomplete case analyses, mismatched units, et cetera.

Type checkers are powerful refactoring tools. Anecdotally, at work, once we had to restructure approximately fifty modules, while separating part of those into a library and fusing arguments into structures in another part of those. The whole refactoring was done and released by one person in one working day. It would have been impossible without a type checker to ensure completeness of said refactoring.

Notorious for a steep learning curve and perceived feature development slow-down, languages with type systems--granted a certain engineering savviness--can serve as amazing facilitators of rapid prototyping. The goal of prototyping is often figure out the best specification for the requirements at hand. Expressive type systems often allow to encode relationships between domain entities without writing complex business logic. If one views types as propositions and values of said types as proofs of said propositions, this approach makes a lot of sense. Of course, mileage can vary and it works better the less side-effects there are in a system, but remember that you can simulate side effects via type encodings too! For instance, instead of making actual HTTP requests, you can wrap your data in constructors like HTTPReq and HTTPResp. This approach is similar to, but more pragmatic than, and less insightful than, denotational design [5]. Denotational design is criticised by some [6].

These days, usage of higher-order and anonymous functions is prominent even in more conservative ecosystems like Java's. Type systems greatly assist in reasoning about the code's overall behaviour. In general, type systems are one of many tools for writing self-documenting code.

Type systems also enable and encourage writing composable code, meaning that the programmers are nudged towards writing well-structured and modular code bases, no matter what is the unit of modularity: a Java class or a Haskell module.

### Drawbacks of type systems

Type systems aren't entirely free. Both the users (programmers) and the computer itself have to do extra work to write a program that would be accepted by a language with a type system. Sometimes, that work takes non-trivial amounts of computational time, but in practice, it's seldom more computationally intense than, say, code generation via templates.

Also, not quite a drawback, but rather something many people don't understand about type systems. There's an "if it compiles, it works" meme, but it's extremely misleading. Type systems, by their static nature, can't prove presence of features of a program, only absence. But this yields a couple of actual drawbacks:

- With type systems, you almost always pick your fights. Languages geared towards eliminating one kind of bad program behaviours won't eliminate another, perhaps, side-stepping it altogether by deferring it to the language runtime.
- Scrutiny, thus power, of type systems is always in tension with expressiveness, which is understood as the measure of the programs that are well-behaved at runtime, which are rejected by the type checker.
- Sometimes complex type checking algorithms rely on heuristics, which limit expressiveness in ways, unexpected by the user [7].

### Bottom line

We'll end this section with a nice heuristic for architects to think about using type systems is to perform the following thought experiment:

 1. Approximate how much would it cost to write, deploy and run a 100%-coverage random testing system, searching for runtime errors
 2. Approximate how much would it cost to train developers to use a "tight" type system, which would give the same sort of guarantees "for free" and in static fashion.

If cost 2 is even comparable to, let alone lower than, cost 1, going for using type systems to refuse incorrect programs is warranted. Quoting "The Toyota Way":

> Focusing on quality actually reduced cost more than focusing only on cost.

# Links

## Formal methods

=> https://www.youtube.com/watch?v=VUr5jiQvUMY [1]: Formal Verification (in Embedded Systems Design), Prof. Anupam Basu, NPTEL
=> https://d-nb.info/1010333739/34 [2]: Formal Verification Methodologies for Nonlinear Analog Circuits, Dr. S. Steinhorst, Ph.D. thesis
=> https://ieeexplore.ieee.org/document/6229788 [3]: EMFtoCSP: A tool for the lightweight verification of EMF models, C. A. Gonzalez et al.
=> https://dlang.org/spec/contracts.html [4]: Contract Programming, DLang website
=> https://github.com/conal/talk-2014-lambdajam-denotational-design [5]: Denotational Design: from meanings to programs, C. Elliott
=> https://ro-che.info/articles/2014-12-31-denotational-design-does-not-work [6]: Denotational design does not work, R. Cheplyaka
=> https://www.youtube.com/watch?v=jNbb5JVuq-o [7]: Dependency Analysis of Haskell Declarations, Artem Kuznetsov

