# Innovative type systems: case studies of mainstream adoption

## Why not settle for naive / simple type systems?

As was discussed in the previous post about type systems, type systems, by definition, limit the expressiveness of languages. And yet, they are well worth it as far as budgets are concerned. Let's start this post with exploring a classical expressiveness shortcoming of languages with type systems: the problem of operating on heterogenous data.

Consider needing to store a hierarchy of countries and cities in the same tree. An untyped approach would be simple: make distinct objects for countries, cities, neighbourhoods and then add `children` field to each, putting necessary objects on lower levels of the hierarchy:

```Dynamic hierarchy in JavaScript
let city1 = {"name": "Riga", "longestStreet": "Brivibas"};
let city2 = {"name": "Zagreb", "longestStreet": "Ilica"};
let country1 = {"name": "Latvia", "ownName": "Latvija", "capital": city1};
let country2 = {"name": "Croatia", "ownName": "Hrvatska", "capital": city2};
let city11 = {"name": "Zilupe", "longestStreet": "Brivibas"};
let city22 = {"name": "Split", "longestStreet": "Domovinskog Rata"};
let world =
  {"name": "Earth",
   "children":
     [{...country1, "children": [city1, city11]},
      {...country2, "children": [city2, city22]}]
  };
```

Naively, the same can be achieved with simply having a tree type, parametrised with a union type that encodes either a City or a Country.

```A union type in Haskell
data World = World { name :: Text }
data Country = Country { name :: Text, capital :: City }
data City = City { name :: Text, longestStreet :: Text }
data Value = W (World, [Country]) | C (Country, [City]) | T City
```

However, quite some problems arise when we want to extend encoding to also capture streets, for instance. Our union type shall change along with type definition for City. This topic is far from being trivial to solve in a polymorphic fashion in typed languages, and it, in part, spawned a whole notion in programming language theory, called "expression problem" [?][?]. Only somewhat recent research demonstrates the possibility of general type-safe computation with heterogenous data [?] by unifying pattern calculus [?] with structural polymorphism [?].

That being said, in well-typed systems, refactoring is cheap and introducing refactoring loops into your feature implementation loop shouldn't be detrimental to time to market compared to using untyped approaches. Furthermore, very often, with a proper architecture the need for computing over heterogenous data can be greatly alleviated.

Generic computing, however, is instrumental to even to the most basic programming since data structures, foundational to the discipline, are intrinsically generic. The question is then, if it is possible to work with them in a type-safe way. A motivational example would be Java's "Hashtable", as seen in version 1.0, dated 7th of January, 1998. Consider its `get` function:

```Java 1.0 "hashtable get"
public synchronized Object get(Object key) {
    HashtableEntry tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    for (HashtableEntry e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) && e.key.equals(key)) {
    	return e.value;
        }
    }
    return null;
}
```

Considerations for the billion dollar mistake [?] aside, when we talk about type safety of this snippet, we see that, on line three of it, we call method `hashCode()` of an instance of class `Object`. This approach to "generics" asks engineers to have a single point in the closed type hierarchy, which mandates all the necessary methods for the generic applications. This approach is a source of headache for library implementers. Even if we negotiate that using Interfaces is good enough for implementing generic programs (think, `get` would accept `IHashable` instead of `Object`), the problems still exist.

* Upcasting [?] to an interface or an Object would result in upcasting of the return value, which would require for downcasting later on, causing runtime errors, throwing away type guarantees.
* Overlapping abstract method names in interfaces without resolving facilities make generic programming via upcasting less scalable.

The pioneering language in the modern type systems engineering, which gave raise to Haskell and Ocaml is called "ML". ML, in mid-seventies, has introduced something called "parametric polymorphism", the idea of which is to let programmers write function signatures with bound and scoped type variables. Modern Java's Hashtable uses parametric polymorphism and is said to be "polymorphic in key and value types":

```Modern class information of hashtable
public class Hashtable<K,V>
extends Dictionary<K,V>
implements Map<K,V>, Cloneable, Serializable
```

A side-note. Type systems with parametric polymorphism allow to reason about properties of systems better. For example, if a test, polymorphic in V, works on some `Hashtable<K, V = a>` h, it shall also work on a `Hashtable<K, V = b>` w, such that w[k] = f(h[k]) for any f.

```ASCII art diagram showing that if test of h is true, then test composed with map f is true and test of w is also true.
 h--test-->true
 |       /
 |      /
map    /
 f    /
 |  test
 |  /
 v /
 w
```

## Case study: type variables for better polymorphism

### Generic Java

As was discussed prior, initial approach to generic programming in Java was to use Object, the common super-class for any Java class. Pizza language, made by Odersky (eventually, creator of Scala) and Wadler (co-designer of Haskell), released one year after Java, was a superset of Java that was a bit more principled and allowed for type variables that would then be "erased" and translated into Object class, automating upcasting and downcasting, thus retaining type safety. It also allows to remove the problem with exponential blow-up of compiled artefacts like the one seen in C++ due to conditional code generation.

Type erasure is greatly misunderstood and some shortcomings of Java type system is misatributed to it, but it's not without its drawbacks. Most notably, one cannot use type variables in Java in to cast values to that type. I.e. `(T)x` is not a valid expression if T is type variable. The other drawback of type erasure is that even if a generic data structure or method is parametrised with a primitive type, the overhead of boxing it (turning it into a Java class) will be carried via erasure. Note that none of the drawbacks of type erasure limit type safety, only expressiveness and performance.

Wadler et al., after Pizza was released, made a minimum viable formalisation of Java, which was instrumental for eventual inclusion of generics in Java in version 1.5, in 2004.

### Generic Go

Inverses the Pizza -> formalism flow, starts with formalism. In part, because the openness of supertyping creates more difficulties. There is no nominal way to say that something belongs to (implements) some interface.

#### Go is structural

Thus, interfaces must be considered in featherweight go.

## Closing thoughts

There are many other examples even within the world of polymorphism, like rediscovery of higher kinded types in C++ (something very little type systems allow for natively), design and inclusion of higher kinded types into Scala by Martin Odersky. There are other examples of mainstream languages adopting concepts from languages with more advanced type systems, such as function type treatment, allowing for ergonomic higher order functions, currying, et cetera. But all in all, we argue that exploration of repeated success of adoption of parametric polymorphism by mainstream languages does good enough job to motivate businesses to look at proceedings









































## Links

=> https://homepages.inf.ed.ac.uk/wadler/papers/expression/expression.txt P. Wadler: The Expression Problem
=> https://wiki.c2.com/?ExpressionProblem C2 Wiki: Expression Problem
=> https://qspace.library.queensu.ca/bitstream/handle/1974/672/Huang_Freeman_Y_200708_PhD.pdf?sequence=1&isAllowed=y F. Y. Huang: Type-Safe Computation with Heterogeneous Data
=> https://www.youtube.com/watch?v=ybrQvs4x0Ps T. Hoare: Null References: The Billion Dollar Mistake
=> https://stackoverflow.com/questions/23414090/what-is-the-difference-between-up-casting-and-down-casting-with-respect-to-class Dhivakar@SO: What is [..] up-casting and down-casting [..]
=> https://www.oracle.com/technetwork/java/javase/generics-tutorial-159168.pdf G. Bracha, Generics in the Java Programming Language
=> http://www.jot.fm/issues/issue_2007_09/article3.pdf M. Debbabi, M. Fourati: A Formal Type System for Java
=> https://www.cis.upenn.edu/~bcpierce/papers/fj-toplas.pdf A. Igarashi, P. Wadler, et al.: Featherweight Java: A Minimal Core Calculus for Java and GJ
=> https://www.youtube.com/watch?v=Dq0WFigax_c  Phil Wadler: Featherweight Go
=> https://www.usenix.org/legacy/publications/compsystems/1989/win_stroustrup.pdf B. Stroustrup: Parametrized Types for C++

